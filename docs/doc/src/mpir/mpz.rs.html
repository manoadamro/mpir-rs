<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/mpz.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mpz.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../mpir/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../mpir/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../mpir/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
</pre><pre class="rust"><code><span class="doccomment">//! Unbounded Integer</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [MPIR 3.0.0 - C documentation](https://mpir.org/mpir-3.0.0.pdf)</span>

<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="ident">size_of</span>, <span class="ident">uninitialized</span>};

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::ctype</span>::{
    <span class="ident">c_char</span>, <span class="ident">c_double</span>, <span class="ident">c_int</span>, <span class="ident">c_long</span>, <span class="ident">c_ulong</span>, <span class="ident">c_void</span>, <span class="ident">mp_bitcnt_t</span>, <span class="ident">mpz_ptr</span>, <span class="ident">mpz_srcptr</span>, <span class="ident">mpz_struct</span>,
    <span class="ident">size_t</span>, <span class="ident">CString</span>, <span class="ident">mp_limb_t</span>
};

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::Sign</span>;

<span class="attribute">#[<span class="ident">link</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;mpir&quot;</span>, <span class="ident">kind</span> <span class="op">=</span> <span class="string">&quot;static&quot;</span>)]</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Constants</span>

    <span class="doccomment">/// The MPIR version number, as a null-terminated string, in the form “i.j.k”.</span>
    <span class="kw">static</span> <span class="ident">mpir_version</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>;

    <span class="doccomment">/// The GNU MP version number, as a null-terminated string, in the form “i.j.k”.</span>
    <span class="kw">static</span> <span class="ident">gmp_version</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>;

    <span class="doccomment">/// The number of bits per limb.</span>
    <span class="kw">static</span> <span class="ident">mp_bits_per_limb</span>: <span class="ident">c_int</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Initialisation Functions</span>

    <span class="comment">/* The functions for integer arithmetic assume that all integer objects are initialized.
    You do that by calling the function mpz_init. For example,
    {
        mpz_t integ;
        mpz_init (integ);
        ...
        mpz_add (integ, ...);
        ...
        mpz_sub (integ, ...);
        /* Unless the program is about to exit, do ... */
        mpz_clear (integ);
    }
    As you can see, you can store new values any number of times, once an object is initialized */</span>

    <span class="doccomment">/// Initialize integer, and set its value to 0</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init</span>(<span class="ident">x</span>: <span class="ident">mpz_ptr</span>);

    <span class="doccomment">/// Initialize integer, with space for n bits, and set its value to 0.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is only the initial space, integer will grow automatically in the normal way, if necessary,</span>
    <span class="doccomment">/// for subsequent values stored. mpz_init2 makes it possible to avoid such reallocations if a</span>
    <span class="doccomment">/// maximum size is known in advance</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init2</span>(<span class="ident">x</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Free the space occupied by integer. Call this function for all mpz_t variables when you are</span>
    <span class="doccomment">/// done with them.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_clear</span>(<span class="ident">x</span>: <span class="ident">mpz_ptr</span>);

    <span class="doccomment">/// Change the space allocated for integer to n bits. The value in integer is preserved if it fits,</span>
    <span class="doccomment">/// or is set to 0 if not.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This function can be used to increase the space for a variable in order to avoid repeated</span>
    <span class="doccomment">/// automatic reallocations, or to decrease it to give memory back to the heap</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_realloc2</span>(<span class="ident">x</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Assignment Functions</span>

    <span class="comment">/* These functions assign new values to already initialized integers */</span>

    <span class="doccomment">/// Set the value of rop from another mpz.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_set</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_ptr</span>);

    <span class="doccomment">/// Set the value of rop from op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_set_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set the value of rop from op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_set_si</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set the value of rop from a C double.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_set_d</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_double</span>);

    <span class="comment">// TODO : when rational is added</span>
    <span class="comment">// /// Set the value of rop from op.</span>
    <span class="comment">// pub fn mpz_set_q (rop: mpz_ptr, op: );</span>

    <span class="comment">// TODO : when float is added</span>
    <span class="comment">// /// Set the value of rop from op.</span>
    <span class="comment">// pub fn mpz_set_f (rop: mpz_ptr, op: mpf_ptr);</span>

    <span class="doccomment">/// Set the value of rop from str, a null-terminated C string in base base. White space is allowed</span>
    <span class="doccomment">/// in the string, and is simply ignored.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The base may vary from 2 to 62, or if base is 0, then the leading characters are used: 0x and</span>
    <span class="doccomment">/// 0X for hexadecimal, 0b and 0B for binary, 0 for octal, or decimal otherwise.</span>
    <span class="doccomment">/// For bases up to 36, case is ignored; upper-case and lower-case letters have the same value. For</span>
    <span class="doccomment">/// bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent</span>
    <span class="doccomment">/// 36..61.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This function returns 0 if the entire string is a valid number in base base. Otherwise it returns</span>
    <span class="doccomment">/// −1</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_set_str</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">s</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>, <span class="ident">base</span>: <span class="ident">c_int</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Swap the values rop1 and rop2 efficiently</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_swap</span>(<span class="ident">rop1</span>: <span class="ident">mpz_ptr</span>, <span class="ident">rop2</span>: <span class="ident">mpz_ptr</span>);

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Combined Initialization and Assignment Functions</span>

    <span class="comment">/* for convenience, MPIR provides a parallel series of initialize-and-set functions which initialize
    the output and then store the value there. These functions’ names have the form mpz_init_
    set...

    Here is an example of using one:
    {
        mpz_t pie;
        mpz_init_set_str (pie, &quot;3141592653589793238462643383279502884&quot;, 10);
        ...
        mpz_sub (pie, ...);
        ...
        mpz_clear (pie);
    }

    Once the integer has been initialized by any of the mpz_init_set... functions, it can be used
    as the source or destination operand for the ordinary integer functions. Don’t use an initialize-
    and-set function on a variable already initialized! */</span>

    <span class="doccomment">/// Initialize rop with limb space and set the initial numeric value from another mpz.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init_set</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_ptr</span>);

    <span class="doccomment">/// Set the value of rop from op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init_set_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set the value of rop from op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init_set_si</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Initialize rop with limb space and set the initial numeric value from a C double.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init_set_d</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">c_double</span>);

    <span class="doccomment">/// Initialize rop and set its value like mpz_set_str (see its documentation above for details).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the string is a correct base base number, the function returns 0; if an error occurs it returns</span>
    <span class="doccomment">/// −1. rop is initialized even if an error occurs. (I.e., you have to call mpz_clear for it.)</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_init_set_str</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">s</span>: <span class="kw-2">*const</span> <span class="ident">c_char</span>, <span class="ident">base</span>: <span class="ident">c_int</span>) -&gt; <span class="ident">c_int</span>;

    <span class="comment">// Conversion Functions</span>

    <span class="comment">/* This section describes functions for converting MPIR integers to standard C types. */</span>

    <span class="doccomment">/// Return the value of op as an mpir_ui.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If op is too big to fit an mpir_ui then just the least significant bits that do fit are returned.</span>
    <span class="doccomment">/// The sign of op is ignored, only the absolute value is used.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_get_ui</span>(<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="doccomment">/// If op fits into a mpir_si return the value of op. Otherwise return the least significant part</span>
    <span class="doccomment">/// of op, with the same sign as op.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If op is too big to fit in a mpir_si, the returned result is probably not very useful. To find</span>
    <span class="doccomment">/// out if the value will fit, use the function mpz_fits_slong_p.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_get_si</span>(<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="doccomment">/// Convert op to a double, truncating if necessary (ie. rounding towards zero).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the exponent from the conversion is too big, the result is system dependent. An infinity is</span>
    <span class="doccomment">/// returned where available. A hardware overflow trap may or may not occur.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_get_d</span>(<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_double</span>;

    <span class="doccomment">/// Convert op to a double, truncating if necessary (ie. rounding towards zero), and returning</span>
    <span class="doccomment">/// the exponent separately.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The return value is in the range 0.5 ≤ |d| &lt; 1 and the exponent is stored to *exp. d ∗ 2exp is</span>
    <span class="doccomment">/// the (truncated) op value. If op is zero, the return is 0.0 and 0 is stored to *exp.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is similar to the standard C frexp function (see Section “Normalization Functions” in</span>
    <span class="doccomment">/// The GNU C Library Reference Manual).</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_get_d_2exp</span>(<span class="ident">exp</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Convert op to a string of digits in base base. The base may vary from 2 to 36 or from −2 to</span>
    <span class="doccomment">/// −36.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For base in the range 2..36, digits and lower-case letters are used; for −2..−36, digits and</span>
    <span class="doccomment">/// upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in</span>
    <span class="doccomment">/// that significance order) are used.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If str is NULL, the result string is allocated using the current allocation function (see</span>
    <span class="doccomment">/// Chapter 14 [Custom Allocation], page 106). The block will be strlen(str)+1 bytes, that</span>
    <span class="doccomment">/// being exactly enough for the string and null-terminator.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If str is not NULL, it should point to a block of storage large enough for the result, that being</span>
    <span class="doccomment">/// mpz_sizeinbase (op, base) + 2. The two extra bytes are for a possible minus sign, and the</span>
    <span class="doccomment">/// null-terminator.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// A pointer to the result string is returned, being either the allocated block, or the given str.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_get_str</span>(<span class="ident">s</span>: <span class="kw-2">*mut</span> <span class="ident">c_char</span>, <span class="ident">base</span>: <span class="ident">c_int</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="kw-2">*mut</span> <span class="ident">c_char</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Arithmetic Functions</span>

    <span class="doccomment">/// Set rop to op1 + op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_add</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 + op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_add_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Set rop to op1 − op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_sub</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 − op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_sub_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to op1 − op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_ui_sub</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">c_ulong</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mul</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mul_si</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_long</span>);

    <span class="doccomment">/// Set rop to op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mul_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to rop + op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_addmul</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to rop + op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_addmul_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to rop − op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_submul</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to rop − op1 × op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_submul_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to op1 × 2op2. This operation can also be defined as a left shift by op2 bits.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mul_2exp</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Set rop to −op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_neg</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to the absolute value of op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_abs</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Division Functions</span>

    <span class="comment">/* Division is undefined if the divisor is zero. Passing a zero divisor to the division or modulo
    functions (including the modular powering functions mpz_powm and mpz_powm_ui), will cause an
    intentional division by zero. This lets a program handle arithmetic exceptions in these functions
    the same way as for normal C int arithmetic.

    Divide n by d, forming a quotient q and/or remainder r. For the 2exp functions, d = 2b. The
    rounding is in three styles, each suiting different applications.

    • cdiv rounds q up towards +∞, and r will have the opposite sign to d. The c stands for
    “ceil”.

    • fdiv rounds q down towards −∞, and r will have the same sign as d. The f stands for
    “floor”.

    • tdiv rounds q towards zero, and r will have the same sign as n. The t stands for
    “truncate”.

    In all cases q and r will satisfy n = qd + r, and r will satisfy 0 ≤ |r| &lt; |d|.
    34 MPIR 3.0.0

    The q functions calculate only the quotient, the r functions only the remainder, and the qr
    functions calculate both. Note that for qr the same variable cannot be passed for both q and
    r, or results will be unpredictable.

    For the ui variants the return value is the remainder, and in fact returning the remainder is
    all the div_ui functions do. For tdiv and cdiv the remainder can be negative, so for those
    the return value is the absolute value of the remainder.

    For the 2exp variants the divisor is 2b. These functions are implemented as right shifts and
    bit masks, but of course they round the same as the other functions.

    For positive n both mpz_fdiv_q_2exp and mpz_tdiv_q_2exp are simple bitwise right shifts.
    For negative n, mpz_fdiv_q_2exp is effectively an arithmetic right shift treating n as twos
    complement the same as the bitwise logical functions do, whereas mpz_tdiv_q_2exp effec-
    tively treats n as sign and magnitude. */</span>

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_q</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_r</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_qr</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_q_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_r_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_qr_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_q_2exp</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cdiv_r_2exp</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_q</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_r</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_qr</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_q_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_r_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_qr_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_q_2exp</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fdiv_r_2exp</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_q</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_r</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_qr</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_q_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_r_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_qr_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">r</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_q_2exp</span>(<span class="ident">q</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tdiv_r_2exp</span>(<span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Set r to n mod d. The sign of the divisor is ignored; the result is always non-negative.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_mod_ui is identical to mpz_fdiv_r_ui above, returning the remainder as well as setting</span>
    <span class="doccomment">/// r. See mpz_fdiv_ui above if only the return value is wanted.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mod</span>(<span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set r to n mod d. The sign of the divisor is ignored; the result is always non-negative.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_mod_ui is identical to mpz_fdiv_r_ui above, returning the remainder as well as setting</span>
    <span class="doccomment">/// r. See mpz_fdiv_ui above if only the return value is wanted.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_mod_ui</span>(<span class="ident">r</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_ulong</span>;

    <span class="doccomment">/// Set q to n/d. These functions produce correct results only when it is known in advance that</span>
    <span class="doccomment">/// d divides n.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// These routines are much faster than the other division functions, and are the best choice</span>
    <span class="doccomment">/// when exact division is known to occur, for example reducing a rational to lowest terms.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_divexact</span>(<span class="ident">q</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set q to n/d. These functions produce correct results only when it is known in advance that</span>
    <span class="doccomment">/// d divides n.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// These routines are much faster than the other division functions, and are the best choice</span>
    <span class="doccomment">/// when exact division is known to occur, for example reducing a rational to lowest terms.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_divexact_ui</span>(<span class="ident">q</span>: <span class="ident">mpz_ptr</span>, <span class="ident">n</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is divisible by d if there exists an integer q satisfying n = qd. Unlike the other division</span>
    <span class="doccomment">/// functions, d = 0 is accepted and following the rule it can be seen that only 0 is considered</span>
    <span class="doccomment">/// divisible by 0.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_divisible_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is divisible by d if there exists an integer q satisfying n = qd. Unlike the other division</span>
    <span class="doccomment">/// functions, d = 0 is accepted and following the rule it can be seen that only 0 is considered</span>
    <span class="doccomment">/// divisible by 0.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_divisible_ui_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is divisible by d if there exists an integer q satisfying n = qd. Unlike the other division</span>
    <span class="doccomment">/// functions, d = 0 is accepted and following the rule it can be seen that only 0 is considered</span>
    <span class="doccomment">/// divisible by 0.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_divisible_2exp_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p</span>
    <span class="doccomment">/// modulo 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is congruent to c mod d if there exists an integer q satisfying n = c + qd. Unlike the other</span>
    <span class="doccomment">/// division functions, d = 0 is accepted and following the rule it can be seen that n and c are</span>
    <span class="doccomment">/// considered congruent mod 0 only when exactly equal.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_congruent_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">c</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">d</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p</span>
    <span class="doccomment">/// modulo 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is congruent to c mod d if there exists an integer q satisfying n = c + qd. Unlike the other</span>
    <span class="doccomment">/// division functions, d = 0 is accepted and following the rule it can be seen that n and c are</span>
    <span class="doccomment">/// considered congruent mod 0 only when exactly equal.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_congruent_ui_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">c</span>: <span class="ident">c_ulong</span>, <span class="ident">d</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p</span>
    <span class="doccomment">/// modulo 2b.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// n is congruent to c mod d if there exists an integer q satisfying n = c + qd. Unlike the other</span>
    <span class="doccomment">/// division functions, d = 0 is accepted and following the rule it can be seen that n and c are</span>
    <span class="doccomment">/// considered congruent mod 0 only when exactly equal.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_congruent_2exp_p</span>(<span class="ident">n</span>: <span class="ident">mpz_ptr</span>, <span class="ident">c</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">b</span>: <span class="ident">mp_bitcnt_t</span>) -&gt; <span class="ident">c_int</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Exponentiation Functions</span>

    <span class="doccomment">/// Set rop to baseexp mod mod.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// A negative exp is supported in mpz_powm if an inverse base−1 mod mod exists (see mpz_</span>
    <span class="doccomment">/// invert in Section 5.9 [Number Theoretic Functions], page 36). If an inverse doesn’t exist</span>
    <span class="doccomment">/// then a divide by zero is raised.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_powm</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">base</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">exp</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">m</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to base^exp mod mod.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// A negative exp is supported in mpz_powm if an inverse base−1 mod mod exists (see mpz_</span>
    <span class="doccomment">/// invert in Section 5.9 [Number Theoretic Functions], page 36). If an inverse doesn’t exist</span>
    <span class="doccomment">/// then a divide by zero is raised.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_powm_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">base</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">exp</span>: <span class="ident">c_ulong</span>, <span class="ident">m</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to base^exp. The case 00 yields 1.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_pow_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">base</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">exp</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to base^exp. The case 00 yields 1.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_ui_pow_ui</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">base</span>: <span class="ident">c_ulong</span>, <span class="ident">exp</span>: <span class="ident">c_ulong</span>);

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Root Extraction Functions</span>

    <span class="doccomment">/// Set rop to b n</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// √opc, the truncated integer part of the nth root of op. Return non-zero if the</span>
    <span class="doccomment">/// computation was exact, i.e., if op is rop to the nth power.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_nthroot</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to b n</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// √opc, the truncated integer part of the nth root of op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_root</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Set root to b n</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// √uc, the truncated integer part of the nth root of u. Set rem to the remainder,</span>
    <span class="doccomment">/// (u − rootn).</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_rootrem</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">rem</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">u</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">n</span>: <span class="ident">c_ulong</span>);

    <span class="doccomment">/// Set rop to b√opc, the truncated integer part of the square root of op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_sqrt</span>(<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop1 to b√opc, like mpz_sqrt. Set rop2 to the remainder (op − rop12), which will be</span>
    <span class="doccomment">/// zero if op is a perfect square.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If rop1 and rop2 are the same variable, the results are undefined.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_sqrtrem</span>(<span class="ident">rop1</span>: <span class="ident">mpz_ptr</span>, <span class="ident">rop2</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Return non-zero if op is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such</span>
    <span class="doccomment">/// that op = ab.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Under this definition both 0 and 1 are considered to be perfect powers. Negative values of</span>
    <span class="doccomment">/// op are accepted, but of course can only be odd perfect powers.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_perfect_power_p</span>(<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero if op is a perfect square, i.e., if the square root of op is an integer. Under</span>
    <span class="doccomment">/// this definition both 0 and 1 are considered to be perfect squares.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_perfect_square_p</span>(<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Number Theoretic Functions</span>

    <span class="comment">// TODO mpz_probable_prime_p</span>
    <span class="comment">// /// Determine whether n is a probable prime with the chance of error being at most 1 in 2^prob.</span>
    <span class="comment">// /// return value is 1 if n is probably prime, or 0 if n is definitely composite.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// This function does some trial divisions to speed up the average case, then some probabilistic</span>
    <span class="comment">// /// primality tests to achieve the desired level of error.</span>
    <span class="comment">// /// div can be used to inform the function that trial division up to div has already been performed</span>
    <span class="comment">// /// on n and so n has NO divisors &lt;= div.Use 0 to inform the function that no trial division has</span>
    <span class="comment">// /// been done.</span>
    <span class="comment">// /// This function interface is preliminary and may change in the future.</span>
    <span class="comment">// pub fn mpz_probable_prime_p (mpz t n, gmp randstate t state, int prob, mpir ui div) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_likely_prime_p</span>
    <span class="comment">// /// Determine whether n is likely a prime, i.e. you can consider it a prime for practical purposes.</span>
    <span class="comment">// /// return value is 1 if n can be considered prime, or 0 if n is definitely composite.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// This function does some trial divisions to speed up the average case, then some probabilistic</span>
    <span class="comment">// /// primality tests. The term “likely” refers to the fact that the number will not have small</span>
    <span class="comment">// /// factors.</span>
    <span class="comment">// /// div can be used to inform the function that trial division up to div has already been performed</span>
    <span class="comment">// /// on n and so n has NO divisors &lt;= div</span>
    <span class="comment">// /// This function interface is preliminary and may change in the future.</span>
    <span class="comment">// pub fn mpz_likely_prime_p(mpz t n, gmp randstate t state, mpir ui div) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_next_prime_candidate</span>
    <span class="comment">// /// Set rop to the next candidate prime greater than op. Note that this function will occasionally</span>
    <span class="comment">// /// return composites. It is designed to give a quick method for generating numbers which do</span>
    <span class="comment">// /// not have small prime factors (less than 1000) and which pass a small number of rounds of</span>
    <span class="comment">// /// Miller-Rabin (just two rounds).The test is designed for speed, assuming that a high quality</span>
    <span class="comment">// /// followup test can then be run to ensure primality.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The variable state must be initialized by calling one of the gmp_randinit functions</span>
    <span class="comment">// /// (Section 9.1 [Random State Initialization], page 67) before invoking this function.</span>
    <span class="comment">// pub fn mpz_next_prime_candidate(mpz t rop, mpz t op, gmp randstate t state);</span>

    <span class="comment">// TODO mpz_gcd</span>
    <span class="comment">// /// Set rop to the greatest common divisor of op1 and op2. The result is always positive even if</span>
    <span class="comment">// /// one or both input operands are negative.</span>
    <span class="comment">// pub fn mpz_gcd(mpz t rop, mpz t op1, mpz t op2);</span>

    <span class="comment">// TODO mpz_gcd_ui</span>
    <span class="comment">// /// Compute the greatest common divisor of op1 and op2. If rop is not NULL, store the result</span>
    <span class="comment">// /// there.</span>
    <span class="comment">// /// If the result is small enough to fit in an mpir_ui, it is returned. If the result does not fit, 0</span>
    <span class="comment">// /// is returned, and the result is equal to the argument op1. Note that the result will always fit</span>
    <span class="comment">// /// if op2 is non-zero.</span>
    <span class="comment">// pub fn mpz_gcd_ui (mpz t rop, mpz t op1, mpir ui op2) -&gt; c_ulong;</span>

    <span class="comment">// TODO mpz_gcdext</span>
    <span class="comment">// /// Set g to the greatest common divisor of a and b, and in addition set s and t to coefficients</span>
    <span class="comment">// /// satisfying as + bt = g. The value in g is always positive, even if one or both of a and b</span>
    <span class="comment">// /// are negative (or zero if both inputs are zero). The values in s and t are chosen such that</span>
    <span class="comment">// /// normally, |s| &lt; |b|/(2g) and |t| &lt; |a|/(2g), and these relations define s and t uniquely. There</span>
    <span class="comment">// /// are a few exceptional cases:</span>
    <span class="comment">// /// If |a| = |b|, then s = 0, t = sgn(b).</span>
    <span class="comment">// /// Otherwise, s = sgn(a) if b = 0 or |b| = 2g, and t = sgn(b) if a = 0 or |a| = 2g.</span>
    <span class="comment">// /// In all cases, s = 0 if and only if g = |b|, i.e., if b divides a or a = b = 0.</span>
    <span class="comment">// /// If t is NULL then that value is not computed.</span>
    <span class="comment">// pub fn mpz_gcdext(mpz t g, mpz t s, mpz t t, const mpz t a, const mpz t b);</span>

    <span class="comment">// TODO mpz_lcm</span>
    <span class="comment">// /// Set rop to the least common multiple of op1 and op2. rop is always positive, irrespective of</span>
    <span class="comment">// /// the signs of op1 and op2. rop will be zero if either op1 or op2 is zero.</span>
    <span class="comment">// pub fn mpz_lcm(mpz t rop, mpz t op1, mpz t op2);</span>

    <span class="comment">// TODO mpz_lcm_ui</span>
    <span class="comment">// /// Set rop to the least common multiple of op1 and op2. rop is always positive, irrespective of</span>
    <span class="comment">// /// the signs of op1 and op2. rop will be zero if either op1 or op2 is zero.</span>
    <span class="comment">// pub fn mpz_lcm_ui (mpz t rop, mpz t op1, mpir ui op2);</span>

    <span class="comment">// TODO mpz_invert</span>
    <span class="comment">// /// Compute the inverse of op1 modulo op2 and put the result in rop. If the inverse exists, the</span>
    <span class="comment">// /// return value is non-zero and rop will satisfy 0 ≤ rop &lt; op2. If an inverse doesn’t exist the</span>
    <span class="comment">// /// return value is zero and rop is undefined.</span>
    <span class="comment">// pub fn mpz_invert (mpz t rop, mpz t op1, mpz t op2) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_jacobi</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ).</span>
    <span class="comment">// /// This is defined only for b odd.</span>
    <span class="comment">// pub fn mpz_jacobi (mpz t a, mpz t b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_legendre</span>
    <span class="comment">// /// Calculate the Legendre symbol ( a p ).</span>
    <span class="comment">// /// This is defined only for p an odd positive prime, and</span>
    <span class="comment">// /// for such p it’s identical to the Jacobi symbol.</span>
    <span class="comment">// pub fn mpz_legendre (mpz t a, mpz t p) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_kronecker</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ) with the Kronecker extension ( a 2 ) = ( 2 a ) when a odd, or( a 2 ) = 0 when a even.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui</span>
    <span class="comment">// /// etc can be used for mixed precision Jacobi symbols too.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 145),</span>
    <span class="comment">// /// or any number theory textbook. See also the example program demos/qcn.c which uses</span>
    <span class="comment">// /// mpz_kronecker_ui on the MPIR website.</span>
    <span class="comment">// pub fn mpz_kronecker (mpz t a, mpz t b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_kronecker_si</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ) with the Kronecker extension ( a 2 ) = ( 2 a ) when a odd, or( a 2 ) = 0 when a even.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui</span>
    <span class="comment">// /// etc can be used for mixed precision Jacobi symbols too.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 145),</span>
    <span class="comment">// /// or any number theory textbook. See also the example program demos/qcn.c which uses</span>
    <span class="comment">// /// mpz_kronecker_ui on the MPIR website.</span>
    <span class="comment">// pub fn mpz_kronecker_si (mpz t a, mpir si b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_kronecker_ui</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ) with the Kronecker extension ( a 2 ) = ( 2 a ) when a odd, or( a 2 ) = 0 when a even.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui</span>
    <span class="comment">// /// etc can be used for mixed precision Jacobi symbols too.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 145),</span>
    <span class="comment">// /// or any number theory textbook. See also the example program demos/qcn.c which uses</span>
    <span class="comment">// /// mpz_kronecker_ui on the MPIR website.</span>
    <span class="comment">// pub fn mpz_kronecker_ui (mpz t a, mpir ui b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_si_kronecker</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ) with the Kronecker extension ( a 2 ) = ( 2 a ) when a odd, or( a 2 ) = 0 when a even.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui</span>
    <span class="comment">// /// etc can be used for mixed precision Jacobi symbols too.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 145),</span>
    <span class="comment">// /// or any number theory textbook. See also the example program demos/qcn.c which uses</span>
    <span class="comment">// /// mpz_kronecker_ui on the MPIR website.</span>
    <span class="comment">// pub fn mpz_si_kronecker (mpir si a, mpz t b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_ui_kronecker</span>
    <span class="comment">// /// Calculate the Jacobi symbol ( a b ) with the Kronecker extension ( a 2 ) = ( 2 a ) when a odd, or( a 2 ) = 0 when a even.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// When b is odd the Jacobi symbol and Kronecker symbol are identical, so mpz_kronecker_ui</span>
    <span class="comment">// /// etc can be used for mixed precision Jacobi symbols too.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// For more information see Henri Cohen section 1.4.2 (see Appendix B [References], page 145),</span>
    <span class="comment">// /// or any number theory textbook. See also the example program demos/qcn.c which uses</span>
    <span class="comment">// /// mpz_kronecker_ui on the MPIR website.</span>
    <span class="comment">// pub fn mpz_ui_kronecker (mpir ui a, mpz t b) -&gt; c_int;</span>

    <span class="comment">// TODO mpz_remove</span>
    <span class="comment">// /// Remove all occurrences of the factor f from op and store the result in rop. The return value</span>
    <span class="comment">// /// is how many such occurrences were removed.</span>
    <span class="comment">// pub fn mpz_remove (mpz t rop, mpz t op, mpz t f) -&gt; mp_bitcnt_t;</span>

    <span class="comment">// TODO mpz_fac_ui</span>
    <span class="comment">// /// Set rop to the factorial of n: mpz_fac_ui computes the plain factorial n!, mpz_2fac_ui</span>
    <span class="comment">// /// computes the double-factorial n!!, and mpz_mfac_uiui the m-multi-factorial n!(m).</span>
    <span class="comment">// pub fn mpz_fac_ui (mpz t rop, unsigned long int n);</span>

    <span class="comment">// TODO mpz_2fac_ui</span>
    <span class="comment">// /// Set rop to the factorial of n: mpz_fac_ui computes the plain factorial n!, mpz_2fac_ui</span>
    <span class="comment">// /// computes the double-factorial n!!, and mpz_mfac_uiui the m-multi-factorial n!(m).</span>
    <span class="comment">// pub fn mpz_2fac_ui (mpz t rop, unsigned long int n);</span>

    <span class="comment">// TODO mpz_mfac_uiui</span>
    <span class="comment">// /// Set rop to the factorial of n: mpz_fac_ui computes the plain factorial n!, mpz_2fac_ui</span>
    <span class="comment">// /// computes the double-factorial n!!, and mpz_mfac_uiui the m-multi-factorial n!(m).</span>
    <span class="comment">// pub fn mpz_mfac_uiui (mpz t rop, unsigned long int n, unsigned long int m);</span>

    <span class="comment">// TODO mpz_primorial_ui</span>
    <span class="comment">// /// Set rop to the primorial of n, i.e. the product of all positive prime numbers ≤ n.</span>
    <span class="comment">// pub fn mpz_primorial_ui (mpz t rop, unsigned long int n);</span>

    <span class="comment">// TODO mpz_bin_ui</span>
    <span class="comment">// /// Compute the binomial coefficient ( n k ) and store the result in rop.</span>
    <span class="comment">// /// Negative values of n are supported by mpz_bin_ui, using the identity ( −n k ) = (−1)k ( n+k−1 k )</span>
    <span class="comment">// pub fn mpz_bin_ui (mpz t rop, mpz t n, mpir ui k);</span>

    <span class="comment">// TODO mpz_bin_uiui</span>
    <span class="comment">// /// Compute the binomial coefficient ( n k ) and store the result in rop.</span>
    <span class="comment">// /// Negative values of n are supported by mpz_bin_ui, using the identity ( −n k ) = (−1)k ( n+k−1 k )</span>
    <span class="comment">// pub fn mpz_bin_uiui (mpz t rop, mpir ui n, mpir ui k);</span>

    <span class="comment">// TODO mpz_fib_ui</span>
    <span class="comment">// /// mpz_fib_ui sets fn to to Fn, the n’th Fibonacci number. mpz_fib2_ui sets fn to Fn, and fnsub1 to Fn−1.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// These functions are designed for calculating isolated Fibonacci numbers. When a sequence of</span>
    <span class="comment">// /// values is wanted it’s best to start with mpz_fib2_ui and iterate the defining Fn+1 = Fn +Fn−1</span>
    <span class="comment">// /// or similar.</span>
    <span class="comment">// fn mpz_fib_ui (mpz t fn, mpir ui n);</span>

    <span class="comment">// TODO mpz_fib2_ui</span>
    <span class="comment">// /// mpz_fib_ui sets pub fn to to Fn, the n’th Fibonacci number. mpz_fib2_ui sets fn to Fn, and fnsub1 to Fn−1.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// These functions are designed for calculating isolated Fibonacci numbers. When a sequence of</span>
    <span class="comment">// /// values is wanted it’s best to start with mpz_fib2_ui and iterate the defining Fn+1 = Fn +Fn−1</span>
    <span class="comment">// /// or similar.</span>
    <span class="comment">// pub fn mpz_fib2_ui (mpz t fn, mpz t fnsub1, mpir ui n);</span>

    <span class="comment">// TODO mpz_lucnum_ui</span>
    <span class="comment">// /// mpz_lucnum_ui sets ln to to Ln, the n’th Lucas number. mpz_lucnum2_ui sets ln to Ln, and</span>
    <span class="comment">// /// lnsub1 to Ln−1.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// These functions are designed for calculating isolated Lucas numbers. When a sequence of</span>
    <span class="comment">// /// values is wanted it’s best to start with mpz_lucnum2_ui and iterate the defining Ln+1 =</span>
    <span class="comment">// /// Ln + Ln−1 or similar.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary</span>
    <span class="comment">// /// to call both mpz_fib2_ui and mpz_lucnum2_ui. The formulas for going from Fibonacci to</span>
    <span class="comment">// pub fn mpz_lucnum_ui (mpz t ln, mpir ui n);</span>

    <span class="comment">// TODO mpz_lucnum2_ui</span>
    <span class="comment">// /// mpz_lucnum_ui sets ln to to Ln, the n’th Lucas number. mpz_lucnum2_ui sets ln to Ln, and</span>
    <span class="comment">// /// lnsub1 to Ln−1.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// These functions are designed for calculating isolated Lucas numbers. When a sequence of</span>
    <span class="comment">// /// values is wanted it’s best to start with mpz_lucnum2_ui and iterate the defining Ln+1 =</span>
    <span class="comment">// /// Ln + Ln−1 or similar.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary</span>
    <span class="comment">// /// to call both mpz_fib2_ui and mpz_lucnum2_ui. The formulas for going from Fibonacci to</span>
    <span class="comment">// pub fn mpz_lucnum2_ui (mpz t ln, mpz t lnsub1, mpir ui n);</span>

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Comparison Functions</span>

    <span class="doccomment">/// Compare op1 and op2. Return a positive value if op1 &gt; op2, zero if op1 = op2, or a negative</span>
    <span class="doccomment">/// value if op1 &lt; op2.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmp_ui and mpz_cmp_si are macros and will evaluate their arguments more than once.</span>
    <span class="doccomment">/// mpz_cmp_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmp</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare op1 and op2. Return a positive value if op1 &gt; op2, zero if op1 = op2, or a negative</span>
    <span class="doccomment">/// value if op1 &lt; op2.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmp_ui and mpz_cmp_si are macros and will evaluate their arguments more than once.</span>
    <span class="doccomment">/// mpz_cmp_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmp_d</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_double</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare op1 and op2. Return a positive value if op1 &gt; op2, zero if op1 = op2, or a negative</span>
    <span class="doccomment">/// value if op1 &lt; op2.</span>
    <span class="doccomment">///cros and will evaluate their arguments more than once.</span>
    <span class="doccomment">/// mpz_cmp_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmp_si</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_long</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare op1 and op2. Return a positive value if op1 &gt; op2, zero if op1 = op2, or a negative</span>
    <span class="doccomment">/// value if op1 &lt; op2.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmp_ui and mpz_cmp_si are macros and will evaluate their arguments more than once.</span>
    <span class="doccomment">/// mpz_cmp_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmp_ui</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare the absolute values of op1 and op2. Return a positive value if |op1| &gt; |op2|, zero</span>
    <span class="doccomment">/// if |op1| = |op2|, or a negative value if |op1| &lt; |op2|.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmpabs_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmpabs</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare the absolute values of op1 and op2. Return a positive value if |op1| &gt; |op2|, zero</span>
    <span class="doccomment">/// if |op1| = |op2|, or a negative value if |op1| &lt; |op2|.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmpabs_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmpabs_d</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_double</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Compare the absolute values of op1 and op2. Return a positive value if |op1| &gt; |op2|, zero</span>
    <span class="doccomment">/// if |op1| = |op2|, or a negative value if |op1| &lt; |op2|.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// mpz_cmpabs_d can be called with an infinity, but results are undefined for a NaN.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_cmpabs_ui</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">c_ulong</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return +1 if op &gt; 0, 0 if op = 0, and −1 if op &lt; 0.</span>
    <span class="doccomment">/// This function is actually implemented as a macro. It evaluates its argument multiple times.</span>
    <span class="kw">fn</span> <span class="ident">mpz_sgn</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Logical and Bit Manipulation Functions</span>

    <span class="comment">/* These functions behave as if twos complement arithmetic were used (although sign-magnitude
    is the actual implementation). The least significant bit is number 0. */</span>

    <span class="doccomment">/// Set rop to op1 bitwise-and op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_and</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 bitwise inclusive-or op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_ior</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to op1 bitwise exclusive-or op2.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_xor</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// Set rop to the one’s complement of op.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_com</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">op</span>: <span class="ident">mpz_srcptr</span>);

    <span class="doccomment">/// If op ≥ 0, return the population count of op, which is the number of 1 bits in the binary</span>
    <span class="doccomment">/// representation. If op &lt; 0, the number of 1s is infinite, and the return value is ULONG MAX,</span>
    <span class="doccomment">/// the largest possible mp_bitcnt_t.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_popcount</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>) -&gt; <span class="ident">mp_bitcnt_t</span>;

    <span class="doccomment">/// If op1 and op2 are both ≥ 0 or both &lt; 0, return the hamming distance between the two</span>
    <span class="doccomment">/// operands, which is the number of bit positions where op1 and op2 have different bit values.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If one operand is ≥ 0 and the other &lt; 0 then the number of bits different is infinite, and the</span>
    <span class="doccomment">/// return value is the largest possible imp_bitcnt_t.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_hamdist</span> (<span class="ident">op1</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">op2</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">mp_bitcnt_t</span>;

    <span class="doccomment">/// Scan op, starting from bit starting bit, towards more significant bits, until the first 0 or 1 bit</span>
    <span class="doccomment">/// (respectively) is found. Return the index of the found bit.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the bit at starting bit is already what’s sought, then starting bit is returned.</span>
    <span class="doccomment">/// If there’s no bit found, then the largest possible mp_bitcnt_t is returned. This will happen</span>
    <span class="doccomment">/// in mpz_scan0 past the end of a positive number, or mpz_scan1 past the end of a nonnegative</span>
    <span class="doccomment">/// number.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_scan0</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">starting_bit</span>: <span class="ident">mp_bitcnt_t</span>) -&gt; <span class="ident">mp_bitcnt_t</span>;

    <span class="doccomment">/// Scan op, starting from bit starting bit, towards more significant bits, until the first 0 or 1 bit</span>
    <span class="doccomment">/// (respectively) is found. Return the index of the found bit.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the bit at starting bit is already what’s sought, then starting bit is returned.</span>
    <span class="doccomment">/// If there’s no bit found, then the largest possible mp_bitcnt_t is returned. This will happen</span>
    <span class="doccomment">/// in mpz_scan0 past the end of a positive number, or mpz_scan1 past the end of a nonnegative</span>
    <span class="doccomment">/// number.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_scan1</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">starting_bit</span>: <span class="ident">mp_bitcnt_t</span>) -&gt; <span class="ident">mp_bitcnt_t</span>;

    <span class="doccomment">/// Set bit bit index in rop.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_setbit</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">bit_index</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Clear bit bit index in rop.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_clrbit</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">bit_index</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Complement bit bit index in rop.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_combit</span> (<span class="ident">rop</span>: <span class="ident">mpz_ptr</span>, <span class="ident">bit_index</span>: <span class="ident">mp_bitcnt_t</span>);

    <span class="doccomment">/// Test bit bit index in op and return 0 or 1 accordingly.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_tstbit</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">starting_bit</span>: <span class="ident">mp_bitcnt_t</span>) -&gt; <span class="ident">c_int</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Random Number Functions</span>

    <span class="comment">/*
    The random number functions of MPIR come in two groups; older function that rely on a global
    state, and newer functions that accept a state parameter that is read and modified. Please see
    the Chapter 9 [Random Number Functions], page 67 for more information on how to use and
    not to use random number functions.
    */</span>

    <span class="comment">// TODO mpz_urandomb</span>
    <span class="comment">// /// Generate a uniformly distributed random integer in the range 0 to 2n − 1, inclusive.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The variable state must be initialized by calling one of the gmp_randinit functions</span>
    <span class="comment">// /// (Section 9.1 [Random State Initialization], page 67) before invoking this function.</span>
    <span class="comment">// pub fn mpz_urandomb (mpz t rop, gmp randstate t state, mp bitcnt t n);</span>

    <span class="comment">// TODO mpz_urandomm</span>
    <span class="comment">// /// Generate a uniform random integer in the range 0 to n − 1, inclusive.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The variable state must be initialized by calling one of the gmp_randinit functions</span>
    <span class="comment">// /// (Section 9.1 [Random State Initialization], page 67) before invoking this function.</span>
    <span class="comment">// pub fn mpz_urandomm (mpz t rop, gmp randstate t state, mpz t n);</span>

    <span class="comment">// TODO mpz_rrandomb</span>
    <span class="comment">// /// Generate a random integer with long strings of zeros and ones in the binary representation.</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// Useful for testing functions and algorithms, since this kind of random numbers have proven</span>
    <span class="comment">// /// to be more likely to trigger corner-case bugs. The random number will be in the range 0 to</span>
    <span class="comment">// /// 2n − 1, inclusive.</span>
    <span class="comment">// /// The variable state must be initialized by calling one of the gmp_randinit functions</span>
    <span class="comment">// /// (Section 9.1 [Random State Initialization], page 67) before invoking this function.</span>
    <span class="comment">// pub fn mpz_rrandomb (mpz t rop, gmp randstate t state, mp bitcnt t n);</span>

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Miscellaneous Functions</span>

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_ulong_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_slong_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_uint_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_sint_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_ushort_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed</span>
    <span class="doccomment">/// int, unsigned short int, or signed short int, respectively. Otherwise, return zero.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_fits_sshort_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Determine whether op is odd or even, respectively. Return non-zero if yes, zero if no. These</span>
    <span class="doccomment">/// macros evaluate their argument more than once.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_odd_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Determine whether op is odd or even, respectively. Return non-zero if yes, zero if no. These</span>
    <span class="doccomment">/// macros evaluate their argument more than once.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_even_p</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">c_int</span>;

    <span class="doccomment">/// Return the size of op measured in number of digits in the given base. base can vary from 2</span>
    <span class="doccomment">/// to 36.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The sign of op is ignored, just the absolute value is used. The result will be either</span>
    <span class="doccomment">/// exact or 1 too big. If base is a power of 2, the result is always exact. If op is zero the return</span>
    <span class="doccomment">/// value is always 1.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This function can be used to determine the space required when converting op to a string. The</span>
    <span class="doccomment">/// right amount of allocation is normally two more than the value returned by mpz_sizeinbase,</span>
    <span class="doccomment">/// one extra for a minus sign and one for the null-terminator.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// It will be noted that mpz_sizeinbase(op,2) can be used to locate the most significant 1 bit</span>
    <span class="doccomment">/// in op, counting from 1. (Unlike the bitwise functions which start from 0, See Section 5.11</span>
    <span class="doccomment">/// [Logical and Bit Manipulation Functions], page 39.)</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">mpz_sizeinbase</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>, <span class="ident">base</span>: <span class="ident">c_int</span>) -&gt; <span class="ident">size_t</span>;

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
    <span class="comment">// Special Functions</span>

    <span class="comment">/* The functions in this section are for various special purposes. Most applications will not need
    them. */</span>

    <span class="comment">// TODO mpz_array_init</span>
    <span class="comment">// /// This is a special type of initialization. Fixed space of fixed num bits is allocated to each of</span>
    <span class="comment">// /// the array size integers in integer array. There is no way to free the storage allocated by this</span>
    <span class="comment">// /// function. Don’t call mpz_clear!</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// The integer array parameter is the first mpz_t in the array. For example,</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// mpz_t arr[20000];</span>
    <span class="comment">// /// mpz_array_init (arr[0], 20000, 512);</span>
    <span class="comment">// ///</span>
    <span class="comment">// /// This function is only intended for programs that create a large number of integers and need</span>
    <span class="comment">// /// to reduce memory usage by avoiding the overheads of allocating and reallocating lots of small</span>
    <span class="comment">// /// blocks. In normal programs this function is not recommended.</span>
    <span class="comment">// /// The space allocated to each integer by this function will not be automatically increased, unlike</span>
    <span class="comment">// /// the normal mpz_init, so an application must ensure it is sufficient for any value stored. The</span>
    <span class="comment">// /// following space requirements apply to various routines,</span>
    <span class="comment">// /// 44 MPIR 3.0.0</span>
    <span class="comment">// /// • mpz_abs, mpz_neg, mpz_set, mpz_set_si and mpz_set_ui need room for the value they</span>
    <span class="comment">// /// store.</span>
    <span class="comment">// /// • mpz_add, mpz_add_ui, mpz_sub and mpz_sub_ui need room for the larger of the two</span>
    <span class="comment">// /// operands, plus an extra mp_bits_per_limb.</span>
    <span class="comment">// /// • mpz_mul, mpz_mul_ui and mpz_mul_ui need room for the sum of the number of bits in</span>
    <span class="comment">// /// their operands, but each rounded up to a multiple of mp_bits_per_limb.</span>
    <span class="comment">// /// • mpz_swap can be used between two array variables, but not between an array and a</span>
    <span class="comment">// /// normal variable.</span>
    <span class="comment">// /// For other functions, or if in doubt, the suggestion is to calculate in a regular mpz_init variable</span>
    <span class="comment">// /// and copy the result to an array variable with mpz_set.</span>
    <span class="comment">// /// This function is obsolete. It will disappear from future MPIR releases.</span>
    <span class="comment">// pub fn mpz_array_init(mpz t integer_array, size t array_size, mp size t fixed_num_bits);</span>

    <span class="comment">// TODO _mpz_realloc</span>
    <span class="comment">// /// Change the space for integer to new alloc limbs. The value in integer is preserved if it fits,</span>
    <span class="comment">// /// or is set to 0 if not. The return value is not useful to applications and should be ignored.</span>
    <span class="comment">// /// mpz_realloc2 is the preferred way to accomplish allocation changes like this. mpz_realloc2</span>
    <span class="comment">// /// and _mpz_realloc are the same except that _mpz_realloc takes its size in limbs.</span>
    <span class="comment">// void * _mpz_realloc (mpz t integer, mp size t new_alloc)</span>

    <span class="comment">// TODO mpz_getlimbn</span>
    <span class="comment">// /// Return limb number n from op. The sign of op is ignored, just the absolute value is used.</span>
    <span class="comment">// /// The least significant limb is number 0.</span>
    <span class="comment">// /// mpz_size can be used to find how many limbs make up op. mpz_getlimbn returns zero if n</span>
    <span class="comment">// /// is outside the range 0 to mpz_size(op)-1.</span>
    <span class="comment">// mp_limb_t mpz_getlimbn (mpz t op, mp size t n)</span>

    <span class="doccomment">/// Return the size of op measured in number of limbs. If op is zero, the returned value will be</span>
    <span class="doccomment">/// zero.</span>
    <span class="kw">fn</span> <span class="ident">mpz_size</span> (<span class="ident">op</span>: <span class="ident">mpz_srcptr</span>) -&gt; <span class="ident">size_t</span>;

    <span class="comment">// TODO mpz_limbs_read</span>
    <span class="comment">// /// Return a pointer to the limb array representing the absolute value of x.</span>
    <span class="comment">// /// The size of the array is mpz_size(x). Intended for read access only.</span>
    <span class="comment">// const mp_limb_t * mpz_limbs_read (const mpz t x)</span>

    <span class="comment">// TODO mpz_limbs_write</span>
    <span class="comment">// /// Return a pointer to the limb array, intended for write access. The array is reallocated as</span>
    <span class="comment">// /// needed, to make room for n limbs. Requires n &gt; 0. The mpz_limbs_modify function returns</span>
    <span class="comment">// /// an array that holds the old absolute value of x, while mpz_limbs_write may destroy the old</span>
    <span class="comment">// /// value and return an array with unspecified contents.</span>
    <span class="comment">// mp_limb_t * mpz_limbs_write (mpz t x, mp size t n)</span>

    <span class="comment">// TODO mpz_limbs_modify</span>
    <span class="comment">// /// Return a pointer to the limb array, intended for write access. The array is reallocated as</span>
    <span class="comment">// /// needed, to make room for n limbs. Requires n &gt; 0. The mpz_limbs_modify function returns</span>
    <span class="comment">// /// an array that holds the old absolute value of x, while mpz_limbs_write may destroy the old</span>
    <span class="comment">// /// value and return an array with unspecified contents.</span>
    <span class="comment">// mp_limb_t * mpz_limbs_modify (mpz t x, mp size t n)</span>

    <span class="comment">// TODO mpz_limbs_finish</span>
    <span class="comment">// /// Updates the internal size field of x. Used after writing to the limb array pointer returned</span>
    <span class="comment">// /// by mpz_limbs_write or mpz_limbs_modify is completed. The array should contain |s| valid</span>
    <span class="comment">// /// limbs, representing the new absolute value for x, and the sign of x is taken from the sign of</span>
    <span class="comment">// /// s. This function never reallocates x, so the limb pointer remains valid.</span>
    <span class="comment">// /// void foo (mpz_t x)</span>
    <span class="comment">// /// {</span>
    <span class="comment">// /// mp_size_t n, i;</span>
    <span class="comment">// /// mp_limb_t *xp;</span>
    <span class="comment">// /// Chapter 5: Integer Functions 45</span>
    <span class="comment">// /// n = mpz_size (x);</span>
    <span class="comment">// /// xp = mpz_limbs_modify (x, 2*n);</span>
    <span class="comment">// /// for (i = 0; i &lt; n; i++)</span>
    <span class="comment">// /// xp[n+i] = xp[n-1-i];</span>
    <span class="comment">// /// mpz_limbs_finish (x, mpz_sgn (x) &lt; 0 ? - 2*n : 2*n);</span>
    <span class="comment">// /// }</span>
    <span class="comment">// pub fn mpz_limbs_finish (mpz t x, mp size t s);</span>

    <span class="comment">// TODO mpz_roinit_n</span>
    <span class="comment">// /// Special initialization of x, using the given limb array and size. x should be treated as read-</span>
    <span class="comment">// /// only: it can be passed safely as input to any mpz function, but not as an output. The array</span>
    <span class="comment">// /// xp must point to at least a readable limb, its size is |xs|, and the sign of x is the sign of xs.</span>
    <span class="comment">// /// For convenience, the function returns x, but cast to a const pointer type.</span>
    <span class="comment">// /// void foo (mpz_t x)</span>
    <span class="comment">// /// {</span>
    <span class="comment">// /// static const mp_limb_t y[3] = { 0x1, 0x2, 0x3 };</span>
    <span class="comment">// /// mpz_t tmp;</span>
    <span class="comment">// /// mpz_add (x, x, mpz_roinit_n (tmp, y, 3));</span>
    <span class="comment">// /// }</span>
    <span class="comment">// mpz_srcptr mpz_roinit_n (mpz t x, const mp limb t *xp, mp size t xs);</span>

    <span class="comment">// TODO MPZ_ROINIT_N</span>
    <span class="comment">// /// This macro expands to an initializer which can be assigned to an mpz t variable. The</span>
    <span class="comment">// /// limb array xp must point to at least a readable limb, moreover, unlike the mpz_roinit_n</span>
    <span class="comment">// /// function, the array must be normalized: if xs is non-zero, then xp[|xs| − 1] must be non-zero.</span>
    <span class="comment">// /// Intended primarily for constant values. Using it for non-constant values requires a C compiler</span>
    <span class="comment">// /// supporting C99.</span>
    <span class="comment">// /// void foo (mpz_t x)</span>
    <span class="comment">// /// {</span>
    <span class="comment">// /// static const mp_limb_t ya[3] = { 0x1, 0x2, 0x3 };</span>
    <span class="comment">// /// static const mpz_t y = MPZ_ROINIT_N ((mp_limb_t *) ya, 3);</span>
    <span class="comment">// /// mpz_add (x, x, y);</span>
    <span class="comment">// /// }</span>
    <span class="comment">// mpz_t MPZ_ROINIT_N (mp limb t *xp, mp size t xs)</span>

    <span class="comment">// ---------------------------------------------------------------------------------------------</span>
}

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Mpz</span>(<span class="ident">mpz_struct</span>);

<span class="kw">impl</span> <span class="ident">Mpz</span> {}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">test</span> {
    <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">new</span>() {}
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mpir" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>