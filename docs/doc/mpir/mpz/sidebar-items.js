initSidebarItems({"fn":[["mpz_abs","Set rop to the absolute value of op."],["mpz_add","Set rop to op1 + op2."],["mpz_add_ui","Set rop to op1 + op2."],["mpz_addmul","Set rop to rop + op1 × op2."],["mpz_addmul_ui","Set rop to rop + op1 × op2."],["mpz_and","Set rop to op1 bitwise-and op2."],["mpz_cdiv_q",""],["mpz_cdiv_q_2exp",""],["mpz_cdiv_q_ui",""],["mpz_cdiv_qr",""],["mpz_cdiv_qr_ui",""],["mpz_cdiv_r",""],["mpz_cdiv_r_2exp",""],["mpz_cdiv_r_ui",""],["mpz_cdiv_ui",""],["mpz_clear","Free the space occupied by integer. Call this function for all mpz_t variables when you are done with them."],["mpz_clrbit","Clear bit bit index in rop."],["mpz_cmp","Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negative value if op1 < op2."],["mpz_cmp_d","Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negative value if op1 < op2."],["mpz_cmp_si","Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negative value if op1 < op2. cros and will evaluate their arguments more than once. mpz_cmp_d can be called with an infinity, but results are undefined for a NaN."],["mpz_cmp_ui","Compare op1 and op2. Return a positive value if op1 > op2, zero if op1 = op2, or a negative value if op1 < op2."],["mpz_cmpabs","Compare the absolute values of op1 and op2. Return a positive value if |op1| > |op2|, zero if |op1| = |op2|, or a negative value if |op1| < |op2|."],["mpz_cmpabs_d","Compare the absolute values of op1 and op2. Return a positive value if |op1| > |op2|, zero if |op1| = |op2|, or a negative value if |op1| < |op2|."],["mpz_cmpabs_ui","Compare the absolute values of op1 and op2. Return a positive value if |op1| > |op2|, zero if |op1| = |op2|, or a negative value if |op1| < |op2|."],["mpz_com","Set rop to the one’s complement of op."],["mpz_combit","Complement bit bit index in rop."],["mpz_congruent_2exp_p","Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p modulo 2b."],["mpz_congruent_p","Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p modulo 2b."],["mpz_congruent_ui_p","Return non-zero if n is congruent to c modulo d, or in the case of mpz_congruent_2exp_p modulo 2b."],["mpz_divexact","Set q to n/d. These functions produce correct results only when it is known in advance that d divides n."],["mpz_divexact_ui","Set q to n/d. These functions produce correct results only when it is known in advance that d divides n."],["mpz_divisible_2exp_p","Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b."],["mpz_divisible_p","Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b."],["mpz_divisible_ui_p","Return non-zero if n is exactly divisible by d, or in the case of mpz_divisible_2exp_p by 2b."],["mpz_even_p","Determine whether op is odd or even, respectively. Return non-zero if yes, zero if no. These macros evaluate their argument more than once."],["mpz_fdiv_q",""],["mpz_fdiv_q_2exp",""],["mpz_fdiv_q_ui",""],["mpz_fdiv_qr",""],["mpz_fdiv_qr_ui",""],["mpz_fdiv_r",""],["mpz_fdiv_r_2exp",""],["mpz_fdiv_r_ui",""],["mpz_fdiv_ui",""],["mpz_fits_sint_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_fits_slong_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_fits_sshort_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_fits_uint_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_fits_ulong_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_fits_ushort_p","Return non-zero iff the value of op fits in an unsigned long, long, unsigned int, signed int, unsigned short int, or signed short int, respectively. Otherwise, return zero."],["mpz_get_d","Convert op to a double, truncating if necessary (ie. rounding towards zero)."],["mpz_get_d_2exp","Convert op to a double, truncating if necessary (ie. rounding towards zero), and returning the exponent separately."],["mpz_get_si","If op fits into a mpir_si return the value of op. Otherwise return the least significant part of op, with the same sign as op."],["mpz_get_str","Convert op to a string of digits in base base. The base may vary from 2 to 36 or from −2 to −36."],["mpz_get_ui","Return the value of op as an mpir_ui."],["mpz_hamdist","If op1 and op2 are both ≥ 0 or both < 0, return the hamming distance between the two operands, which is the number of bit positions where op1 and op2 have different bit values."],["mpz_init","Initialize integer, and set its value to 0"],["mpz_init2","Initialize integer, with space for n bits, and set its value to 0."],["mpz_init_set","Initialize rop with limb space and set the initial numeric value from another mpz."],["mpz_init_set_d","Initialize rop with limb space and set the initial numeric value from a C double."],["mpz_init_set_si","Set the value of rop from op."],["mpz_init_set_str","Initialize rop and set its value like mpz_set_str (see its documentation above for details)."],["mpz_init_set_ui","Set the value of rop from op."],["mpz_ior","Set rop to op1 bitwise inclusive-or op2."],["mpz_mod","Set r to n mod d. The sign of the divisor is ignored; the result is always non-negative."],["mpz_mod_ui","Set r to n mod d. The sign of the divisor is ignored; the result is always non-negative."],["mpz_mul","Set rop to op1 × op2."],["mpz_mul_2exp","Set rop to op1 × 2op2. This operation can also be defined as a left shift by op2 bits."],["mpz_mul_si","Set rop to op1 × op2."],["mpz_mul_ui","Set rop to op1 × op2."],["mpz_neg","Set rop to −op."],["mpz_nthroot","Set rop to b n"],["mpz_odd_p","Determine whether op is odd or even, respectively. Return non-zero if yes, zero if no. These macros evaluate their argument more than once."],["mpz_perfect_power_p","Return non-zero if op is a perfect power, i.e., if there exist integers a and b, with b > 1, such that op = ab."],["mpz_perfect_square_p","Return non-zero if op is a perfect square, i.e., if the square root of op is an integer. Under this definition both 0 and 1 are considered to be perfect squares."],["mpz_popcount","If op ≥ 0, return the population count of op, which is the number of 1 bits in the binary representation. If op < 0, the number of 1s is infinite, and the return value is ULONG MAX, the largest possible mp_bitcnt_t."],["mpz_pow_ui","Set rop to base^exp. The case 00 yields 1."],["mpz_powm","Set rop to baseexp mod mod."],["mpz_powm_ui","Set rop to base^exp mod mod."],["mpz_realloc2","Change the space allocated for integer to n bits. The value in integer is preserved if it fits, or is set to 0 if not."],["mpz_root","Set rop to b n"],["mpz_rootrem","Set root to b n"],["mpz_scan0","Scan op, starting from bit starting bit, towards more significant bits, until the first 0 or 1 bit (respectively) is found. Return the index of the found bit."],["mpz_scan1","Scan op, starting from bit starting bit, towards more significant bits, until the first 0 or 1 bit (respectively) is found. Return the index of the found bit."],["mpz_set","Set the value of rop from another mpz."],["mpz_set_d","Set the value of rop from a C double."],["mpz_set_si","Set the value of rop from op."],["mpz_set_str","Set the value of rop from str, a null-terminated C string in base base. White space is allowed in the string, and is simply ignored."],["mpz_set_ui","Set the value of rop from op."],["mpz_setbit","Set bit bit index in rop."],["mpz_sizeinbase","Return the size of op measured in number of digits in the given base. base can vary from 2 to 36."],["mpz_sqrt","Set rop to b√opc, the truncated integer part of the square root of op."],["mpz_sqrtrem","Set rop1 to b√opc, like mpz_sqrt. Set rop2 to the remainder (op − rop12), which will be zero if op is a perfect square."],["mpz_sub","Set rop to op1 − op2."],["mpz_sub_ui","Set rop to op1 − op2."],["mpz_submul","Set rop to rop − op1 × op2."],["mpz_submul_ui","Set rop to rop − op1 × op2."],["mpz_swap","Swap the values rop1 and rop2 efficiently"],["mpz_tdiv_q",""],["mpz_tdiv_q_2exp",""],["mpz_tdiv_q_ui",""],["mpz_tdiv_qr",""],["mpz_tdiv_qr_ui",""],["mpz_tdiv_r",""],["mpz_tdiv_r_2exp",""],["mpz_tdiv_r_ui",""],["mpz_tdiv_ui",""],["mpz_tstbit","Test bit bit index in op and return 0 or 1 accordingly."],["mpz_ui_pow_ui","Set rop to base^exp. The case 00 yields 1."],["mpz_ui_sub","Set rop to op1 − op2."],["mpz_xor","Set rop to op1 bitwise exclusive-or op2."]],"struct":[["Mpz",""]]});