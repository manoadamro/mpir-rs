var searchIndex = JSON.parse('{\
"mpir":{"doc":"mpir-rs","t":[0,0,0,3,12,12,12,11,11,11,11,11,11,11,11,11,11,11,6,6,6,6,6,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,6,6,6,6,3,11,11,11,6,11,11,11,11,11,11,11,11,11,11,3,11,11,11,11,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,11,11,11,13,13,4,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["ctype","mpz","sign","CString","_mp_alloc","_mp_d","_mp_size","as_bytes","as_bytes_with_nul","as_c_str","as_ref","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","c_char","c_double","c_int","c_long","c_ulong","c_void","clone","clone_into","cmp","default","deref","drop","eq","fmt","fmt","from","from","from","from","from","from","from","from_raw","from_vec_unchecked","from_vec_with_nul","from_vec_with_nul_unchecked","hash","index","into","into","into","into_boxed_c_str","into_bytes","into_bytes_with_nul","into_raw","into_string","mp_bitcnt_t","mp_limb_t","mpz_ptr","mpz_srcptr","mpz_struct","ne","new","partial_cmp","size_t","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","Mpz","borrow","borrow_mut","from","into","mpz_abs","mpz_add","mpz_add_ui","mpz_addmul","mpz_addmul_ui","mpz_and","mpz_cdiv_q","mpz_cdiv_q_2exp","mpz_cdiv_q_ui","mpz_cdiv_qr","mpz_cdiv_qr_ui","mpz_cdiv_r","mpz_cdiv_r_2exp","mpz_cdiv_r_ui","mpz_cdiv_ui","mpz_clear","mpz_clrbit","mpz_cmp","mpz_cmp_d","mpz_cmp_si","mpz_cmp_ui","mpz_cmpabs","mpz_cmpabs_d","mpz_cmpabs_ui","mpz_com","mpz_combit","mpz_congruent_2exp_p","mpz_congruent_p","mpz_congruent_ui_p","mpz_divexact","mpz_divexact_ui","mpz_divisible_2exp_p","mpz_divisible_p","mpz_divisible_ui_p","mpz_even_p","mpz_fdiv_q","mpz_fdiv_q_2exp","mpz_fdiv_q_ui","mpz_fdiv_qr","mpz_fdiv_qr_ui","mpz_fdiv_r","mpz_fdiv_r_2exp","mpz_fdiv_r_ui","mpz_fdiv_ui","mpz_fits_sint_p","mpz_fits_slong_p","mpz_fits_sshort_p","mpz_fits_uint_p","mpz_fits_ulong_p","mpz_fits_ushort_p","mpz_get_d","mpz_get_d_2exp","mpz_get_si","mpz_get_str","mpz_get_ui","mpz_hamdist","mpz_init","mpz_init2","mpz_init_set","mpz_init_set_d","mpz_init_set_si","mpz_init_set_str","mpz_init_set_ui","mpz_ior","mpz_mod","mpz_mod_ui","mpz_mul","mpz_mul_2exp","mpz_mul_si","mpz_mul_ui","mpz_neg","mpz_nthroot","mpz_odd_p","mpz_perfect_power_p","mpz_perfect_square_p","mpz_popcount","mpz_pow_ui","mpz_powm","mpz_powm_ui","mpz_realloc2","mpz_root","mpz_rootrem","mpz_scan0","mpz_scan1","mpz_set","mpz_set_d","mpz_set_si","mpz_set_str","mpz_set_ui","mpz_setbit","mpz_sizeinbase","mpz_sqrt","mpz_sqrtrem","mpz_sub","mpz_sub_ui","mpz_submul","mpz_submul_ui","mpz_swap","mpz_tdiv_q","mpz_tdiv_q_2exp","mpz_tdiv_q_ui","mpz_tdiv_qr","mpz_tdiv_qr_ui","mpz_tdiv_r","mpz_tdiv_r_2exp","mpz_tdiv_r_ui","mpz_tdiv_ui","mpz_tstbit","mpz_ui_pow_ui","mpz_ui_sub","mpz_xor","try_from","try_into","type_id","Negative","Positive","Sign","Zero","borrow","borrow_mut","clone","clone_into","cmp","eq","fmt","from","hash","into","partial_cmp","to_owned","try_from","try_into","type_id"],"q":["mpir","","","mpir::ctype","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","mpir::mpz","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","mpir::sign","","","","","","","","","","","","","","","","","",""],"d":["","Unbounded Integer","For pos/neg checks","A type representing an owned, C-compatible, nul-terminated …","","","","Returns the contents of this <code>CString</code> as a slice of bytes.","Equivalent to <code>CString::as_bytes()</code> except that the returned …","Extracts a <code>CStr</code> slice containing the entire string.","","","","","","","","","","","","","","Equivalent to C’s <code>void</code> type when used as a pointer.","","","","Creates an empty <code>CString</code>.","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Converts a <code>Cow&lt;&#39;a, CStr&gt;</code> into a <code>CString</code>, by copying the …","Copies the contents of the <code>&amp;CStr</code> into a newly allocated …","Converts a Box&lt;CStr&gt; into a <code>CString</code> without copying or …","Converts a Vec&lt;NonZeroU8&gt; into a <code>CString</code> without copying …","Returns the argument unchanged.","Retakes ownership of a <code>CString</code> that was transferred to C …","Creates a C-compatible string by consuming a byte vector, …","Attempts to converts a Vec&lt;u8&gt; to a <code>CString</code>.","Converts a Vec&lt;u8&gt; to a <code>CString</code> without checking the …","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts this <code>CString</code> into a boxed <code>CStr</code>.","Consumes the <code>CString</code> and returns the underlying byte …","Equivalent to <code>CString::into_bytes()</code> except that the …","Consumes the <code>CString</code> and transfers ownership of the string …","Converts the <code>CString</code> into a <code>String</code> if it contains valid …","","","","","","","Creates a new C-compatible string from a container of …","","","","","","","","","","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Set rop to the absolute value of op.","Set rop to op1 + op2.","Set rop to op1 + op2.","Set rop to rop + op1 × op2.","Set rop to rop + op1 × op2.","Set rop to op1 bitwise-and op2.","","","","","","","","","","Free the space occupied by integer. Call this function for …","Clear bit bit index in rop.","Compare op1 and op2. Return a positive value if op1 &gt; op2, …","Compare op1 and op2. Return a positive value if op1 &gt; op2, …","Compare op1 and op2. Return a positive value if op1 &gt; op2, …","Compare op1 and op2. Return a positive value if op1 &gt; op2, …","Compare the absolute values of op1 and op2. Return a …","Compare the absolute values of op1 and op2. Return a …","Compare the absolute values of op1 and op2. Return a …","Set rop to the one’s complement of op.","Complement bit bit index in rop.","Return non-zero if n is congruent to c modulo d, or in the …","Return non-zero if n is congruent to c modulo d, or in the …","Return non-zero if n is congruent to c modulo d, or in the …","Set q to n/d. These functions produce correct results only …","Set q to n/d. These functions produce correct results only …","Return non-zero if n is exactly divisible by d, or in the …","Return non-zero if n is exactly divisible by d, or in the …","Return non-zero if n is exactly divisible by d, or in the …","Determine whether op is odd or even, respectively. Return …","","","","","","","","","","Return non-zero iff the value of op fits in an unsigned …","Return non-zero iff the value of op fits in an unsigned …","Return non-zero iff the value of op fits in an unsigned …","Return non-zero iff the value of op fits in an unsigned …","Return non-zero iff the value of op fits in an unsigned …","Return non-zero iff the value of op fits in an unsigned …","Convert op to a double, truncating if necessary (ie. …","Convert op to a double, truncating if necessary (ie. …","If op fits into a mpir_si return the value of op. …","Convert op to a string of digits in base base. The base …","Return the value of op as an mpir_ui.","If op1 and op2 are both ≥ 0 or both &lt; 0, return the …","Initialize integer, and set its value to 0","Initialize integer, with space for n bits, and set its …","Initialize rop with limb space and set the initial numeric …","Initialize rop with limb space and set the initial numeric …","Set the value of rop from op.","Initialize rop and set its value like mpz_set_str (see its …","Set the value of rop from op.","Set rop to op1 bitwise inclusive-or op2.","Set r to n mod d. The sign of the divisor is ignored; the …","Set r to n mod d. The sign of the divisor is ignored; the …","Set rop to op1 × op2.","Set rop to op1 × 2op2. This operation can also be defined …","Set rop to op1 × op2.","Set rop to op1 × op2.","Set rop to −op.","Set rop to b n","Determine whether op is odd or even, respectively. Return …","Return non-zero if op is a perfect power, i.e., if there …","Return non-zero if op is a perfect square, i.e., if the …","If op ≥ 0, return the population count of op, which is …","Set rop to base^exp. The case 00 yields 1.","Set rop to baseexp mod mod.","Set rop to base^exp mod mod.","Change the space allocated for integer to n bits. The …","Set rop to b n","Set root to b n","Scan op, starting from bit starting bit, towards more …","Scan op, starting from bit starting bit, towards more …","Set the value of rop from another mpz.","Set the value of rop from a C double.","Set the value of rop from op.","Set the value of rop from str, a null-terminated C string …","Set the value of rop from op.","Set bit bit index in rop.","Return the size of op measured in number of digits in the …","Set rop to b√opc, the truncated integer part of the …","Set rop1 to b√opc, like mpz_sqrt. Set rop2 to the …","Set rop to op1 − op2.","Set rop to op1 − op2.","Set rop to rop − op1 × op2.","Set rop to rop − op1 × op2.","Swap the values rop1 and rop2 efficiently","","","","","","","","","","Test bit bit index in op and return 0 or 1 accordingly.","Set rop to base^exp. The case 00 yields 1.","Set rop to op1 − op2.","Set rop to op1 bitwise exclusive-or op2.","","","","","","","","","","","","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","",""],"i":[0,0,0,0,1,1,1,2,2,2,2,1,3,2,2,1,3,2,0,0,0,0,0,0,2,2,2,2,2,2,2,3,2,1,3,2,2,2,2,2,2,2,2,2,2,2,1,3,2,2,2,2,2,2,0,0,0,0,0,2,2,2,0,2,1,3,2,1,3,2,1,3,2,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"f":[null,null,null,null,null,null,null,[[["",0]]],[[["",0]]],[[["",0]],["cstr",3]],[[["",0]],["cstr",3]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["cstr",3]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],null,null,null,null,null,null,[[["",0]],["cstring",3]],[[["",0],["",0]]],[[["",0],["cstring",3]],["ordering",4]],[[],["cstring",3]],[[["",0]],["cstr",3]],[[["",0]]],[[["",0],["cstring",3]],["bool",0]],[[["",0],["formatter",3]],["result",4,[["error",3]]]],[[["",0],["formatter",3]],["result",4,[["error",3]]]],[[]],[[]],[[["cow",4,[["cstr",3]]]],["cstring",3]],[[["cstr",3]],["cstring",3]],[[["box",3,[["cstr",3],["global",3]]]],["cstring",3]],[[["vec",3,[["nonzerou8",3],["global",3]]]],["cstring",3]],[[]],[[],["cstring",3]],[[["vec",3,[["u8",0],["global",3]]]],["cstring",3]],[[["vec",3,[["u8",0],["global",3]]]],["result",4,[["cstring",3],["fromvecwithnulerror",3]]]],[[["vec",3,[["u8",0],["global",3]]]],["cstring",3]],[[["",0],["",0]]],[[["",0],["rangefull",3]],["cstr",3]],[[]],[[]],[[]],[[],["box",3,[["cstr",3],["global",3]]]],[[],["vec",3,[["u8",0],["global",3]]]],[[],["vec",3,[["u8",0],["global",3]]]],[[]],[[],["result",4,[["string",3],["intostringerror",3]]]],null,null,null,null,null,[[["",0],["cstring",3]],["bool",0]],[[],["result",4,[["cstring",3],["nulerror",3]]]],[[["",0],["cstring",3]],["option",4,[["ordering",4]]]],null,[[["",0]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],null,[[["",0]],["",0]],[[["",0]],["",0]],[[]],[[]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,null,null,[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["sign",4]],[[["",0],["",0]]],[[["",0],["sign",4]],["ordering",4]],[[["",0],["sign",4]],["bool",0]],[[["",0],["formatter",3]],["result",6]],[[]],[[["",0],["",0]]],[[]],[[["",0],["sign",4]],["option",4,[["ordering",4]]]],[[["",0]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]]],"p":[[3,"mpz_struct"],[3,"CString"],[4,"c_void"],[3,"Mpz"],[4,"Sign"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};